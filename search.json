[{"title":"如何在Electron中读取Windows注册表并获取鼠标光标大小","path":"/posts/2024062121/","content":"介绍了如何使用regedit包在Electron中读取注册表 发现问题在某些场景下，应用程序需要读取系统配置，例如当前用户的鼠标光标大小 这些信息存储在Windows注册表中，但直接访问和读取这些信息可能存在一些挑战 目录列表 HKLM = HKEY_LOCAL_MACHINE：是机器软硬件信息的集散地 HKCU = HKEY_CURRENT_USER：是当前用户所用信息储存地 HKEY_CLASSES_ROOT：文件关联相关信息 HKEY_USERS：所有用户信息 HKEY_CURRENT_CONFIG：当前系统配置 解决方案为了解决这个问题，我选择使用regedit包，这是一个用于Node.js环境下访问Windows注册表的工具 首先，需要在Electron项目中安装regedit包 安装regedit包 在package.json文件中添加依赖： 123&quot;dependencies&quot;: &#123; &quot;regedit&quot;: &quot;3.0.0&quot;&#125; 然后运行npm install命令安装依赖 读取注册表中的鼠标光标大小 以下是一个示例代码： 12345678910const regedit = require(&#x27;regedit&#x27;);regedit.list([&#x27;HKCU\\\\Control Panel\\\\Cursors&#x27;]) .on(&#x27;data&#x27;, function(entry) &#123; let cursorSettings = entry.data.values if (cursorSettings[&#x27;CursorBaseSize&#x27;]) &#123; console.log(&#x27;CursorBaseSize: &#x27; + cursorSettings[&#x27;CursorBaseSize&#x27;].value) &#125; else &#123; console.log(&#x27;CursorBaseSize not found in the registry&#x27;) &#125; &#125;) 例外场景在实际使用过程中，可能会遇到一些例外情况，例如： CursorBaseSize项在注册表中不存在 读取注册表的过程中发生权限问题或其他错误 为了处理这些情况，可以在代码中添加错误处理和默认值： 123456789101112131415161718const regedit = require(&#x27;regedit&#x27;);regedit.list([&#x27;HKCU\\\\Control Panel\\\\Cursors&#x27;]) .on(&#x27;data&#x27;, function(entry) &#123; try &#123; let cursorSettings = entry.data.values if (cursorSettings[&#x27;CursorBaseSize&#x27;]) &#123; console.log(&#x27;CursorBaseSize: &#x27; + cursorSettings[&#x27;CursorBaseSize&#x27;].value) &#125; else &#123; console.log(&#x27;CursorBaseSize not found in the registry&#x27;) &#125; &#125; catch (error) &#123; console.error(&#x27;Error reading the registry: &#x27;, error) &#125; &#125;) .on(&#x27;error&#x27;, function(error) &#123; console.error(&#x27;Error accessing the registry: &#x27;, error) &#125;) 总结通过使用regedit包，我可以在Electron应用中方便地读取Windows注册表中的信息【也可以查询注册表其他键值功能】"},{"title":"Ts/Js 机巧收藏篇","path":"/posts/2023051823/","content":"记录其 Ts/Js 通用技巧 需求扩展全局作用域 使用 declare global 合并数组和对象 数组对象可以使用数组的concat方法或者扩展运算符...来合并 普通对象可以使用对象的assign方法或者扩展运算符...来合并 删除 Json 中不想要的字段和值 使用delete操作符 数组内实现删除/插入/保留等逻辑 删除指定下标对象： arr.splice(index,1) 在指定下标插入对象： arr.splice(index, 0, 对象) 在指定下标替换对象： arr.splice(index, 1, 对象) 保留多少个对象： arr.splice(个数) 属性映射和类型约束 Record 1234567891011121314151617type petsGroup = &quot;dog&quot; | &quot;cat&quot; | &quot;fish&quot;;interface IPetInfo &#123; name: string; age: number;&#125;type IPets = Record&lt;petsGroup, IPetInfo&gt;;type Animal = &quot;Dog&quot; | &quot;Cat&quot; | &quot;Bird&quot;;const animalContent: Record&lt;Animal, JSX.Element&gt; = &#123; Dog: &lt;div&gt;Dog is loyal and friendly.&lt;/div&gt;, Cat: &lt;div&gt;Cat is cute and independent.&lt;/div&gt;, Bird: &lt;div&gt;Bird is colorful and free.&lt;/div&gt;,&#125;;function getAnimalContent(animal: Animal) &#123; return animalContent[animal];&#125; 帧率显示1234567891011121314151617181920let last = Date.now();let ticks = 0;function rafLoop(timestamp) &#123; ticks += 1; if (ticks &gt;= 30) &#123; const now = Date.now(); const diff = now - last const fps = Math.round(1000 / (diff / ticks)); last = now ticks = 0 renderFps(fps) &#125; requestAnimationFrame(rafLoop);&#125; let fpsEl = document.getElementById(&#x27;fps&#x27;);function renderFps(fps) &#123; fpsEl.textContent = fps;&#125; rafLoop(); 异步逻辑123return new Promise((resolve) =&gt; &#123; resolve(1);&#125;);","tags":["typescript"]},{"title":"如何解决electron build、TypeScript和axios的常见问题","path":"/posts/2023041420/","content":"介绍了其中三方面的原因和解决方法 electron-builddownload failed相关原因 由于国内网络环境的原因，有时候下载速度会非常慢，甚至导致超时或失败 解决方法 使用淘宝镜像源来加速下载 使用全局代理 参考文档 electron-builder - npm 淘宝 NPM 镜像 Electron | Build cross-platform desktop apps with JavaScript, HTML, and CSS. Cannot spawn app-builder.exe: Error: spawn UNKNOWN相关原因 pnpm可能会导致一些原生模块没有被正确载入 解决方法[任选其一] 开启全局节点模式[推荐]下载速度可正常观看YouTube即可 下载指定版本electron-build[推荐]移动至C:\\xxx\\AppData\\Local\\electron\\Cache 版本号 链接 23.2.3 23.2.3-win32-x64.zip 23.2.4 23.2.4-win32-x64.zip 24.1.2 24.1.2-win32-x64.zip 25.0.0-alpha.3 25.0.0-alpha.3-win32-x64.zip 25.0.0-alpha.4 25.0.0-alpha.4-win32-x64.zip FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory in Ionic 3解决方法 TypeScript 错误：类型Window上不存在属性X问题TypeScript是一种静态类型检查的编程语言，它可以在编译时发现并报告潜在的错误。但是有时候，当我们使用一些第三方库或者自定义的全局变量时，TypeScript会提示类型“Window”上不存在属性“X”的错误，这是因为TypeScript无法识别这些属性 解决方法 使用类型断言来告诉TypeScript，我们知道这个属性是存在的，只需要在属性前加上(&lt;any&gt;window)即可。例如，如果我们要使用一个名为myVar的全局变量，我们可以这样写：(&lt;any&gt;window).myVar 使用声明合并来扩展Window接口，添加我们需要的属性。只需要在一个.ts文件中写上如下代码即可： 12345declare global &#123; interface Window &#123; myVar: any; &#125;&#125; 参考文档 TypeScript: Handbook - Basic Types TypeScript: Handbook - Declaration Merging axios: timeout of 5000ms exceeded超时问题如何解决axios是一个基于Promise的HTTP客户端，它可以在浏览器和Node.js中使用。它有一个默认的超时时间为5000毫秒，也就是说如果请求在5秒内没有响应，就会抛出一个错误：”timeout of 5000ms exceeded” 解决方法 增加超时时间，可以在创建axios实例时设置timeout选项，也可以在发送请求时设置timeout参数。例如： 12345678const axios = require(&#x27;axios&#x27;);const instance = axios.create(&#123; timeout: 10000,&#125;);axios.get(&#x27;url&#x27;, &#123; timeout: 10000,&#125;); 捕获并处理错误，可以使用catch方法或者try...catch语句来捕获错误，并根据具体情况进行处理。例如，可以重试请求，或者提示用户检查网络连接。例如： 1234567891011121314151617181920212223242526272829axios.get(&#x27;url&#x27;) .then(response =&gt; &#123; // 处理响应数据 &#125;) .catch(error =&gt; &#123; if (error.code === &#x27;ECONNABORTED&#x27;) &#123; console.log(&#x27;请求超时，请重试&#x27;); &#125; else &#123; // 其他错误 console.log(error.message); &#125; &#125;);// 使用try...catch语句捕获错误(async () =&gt; &#123; try &#123; const response = await axios.get(&#x27;url&#x27;); // 处理响应数据 &#125; catch (error) &#123; // 处理错误 if (error.code === &#x27;ECONNABORTED&#x27;) &#123; // 超时错误 console.log(&#x27;请求超时，请重试&#x27;); &#125; else &#123; // 其他错误 console.log(error.message); &#125; &#125;&#125;)(); 参考文档 Axios - npm Handling Errors | Axios Promise.prototype.catch() - JavaScript | MDN try…catch - JavaScript | MDN","tags":["electron","typescript","axios"]},{"title":"electron中的cmd命令执行和监听","path":"/posts/2023041123/","content":"监听CMD命令: 成功、失败、执行结束 使用场景执行系统操作，或者启动其他进程。这时候，我们就需要能够监听CMD命令的执行结果，以便根据不同的情况做出相应的处理 需求目的能够执行任意的CMD命令： 获取其输出[正常/异常] 判断CMD命令是否执行成功 相关实现利用Node.js提供的child_process模块创建一个带有标准输入输出流的子进程，使用spawn方法来执行CMD命令，例如： 12345678910111213141516171819202122232425// 引入child_process模块const &#123; spawn &#125; = require(&#x27;child_process&#x27;);// 执行ping命令const child = spawn(&#x27;ping&#x27;, [&#x27;www.baidu.com&#x27;]);// 监听子进程的标准输出流child.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(`stdout: $&#123;data&#125;`);&#125;);// 监听子进程的标准错误流child.stderr.on(&#x27;data&#x27;, (data) =&gt; &#123; console.error(`stderr: $&#123;data&#125;`);&#125;);// 监听子进程的退出事件child.on(&#x27;close&#x27;, (code) =&gt; &#123; console.log(`child process exited with code $&#123;code&#125;`);&#125;);// 监听子进程的错误事件child.on(&#x27;error&#x27;, (err) =&gt; &#123; console.error(`child process error: $&#123;err&#125;`);&#125;); 相关总结通过使用Node.js的child_process模块，可以监听其CMD命令成功、失败、执行结束等事件。命令执行流程控制还有其它的函数，具体的用法可以参考Node.js的官方文档 参考文档 Electron官网 Node.js child_process模块 Node.js ChildProcess类","tags":["electron","node.js"]},{"title":"electron和vue之间的通信实现","path":"/posts/2023040900/","content":"如何在electron中使用vue进行通信 使用场景&nbsp;&nbsp;&nbsp;&nbsp;electron是一个基于Node.js和Chromium的桌面应用开发框架，它可以让我们使用web技术来创建跨平台的桌面应用&nbsp;&nbsp;vue是一个轻量级的前端框架，它可以让我们使用声明式的模板语法来构建用户界面。&nbsp;&nbsp;如果想要在electron中使用vue来开发界面，那么我们就需要解决一个问题：如何在electron的主进程和渲染进程之间进行通信和执行相关的逻辑 需求目的&nbsp;&nbsp;&nbsp;&nbsp;electron的主进程和渲染进程之间是相互隔离的，它们不能直接访问对方的变量或函数。因此，我们需要一种ipc机制来实现它们之间的通信和协作 相关实现 首先，在vue中引入ipcRenderer模块。例如:12const electron = require(&#x27;electron&#x27;);const ipc = electron.ipcRenderer; 其次，在主进程中引入ipcMain模块。由于主进程运行在Node.js环境中，我们可以直接使用import或者require方法来引入ipcMain模块。例如：123import &#123; ipcMain &#125; from &#x27;electron&#x27;;// 或者const &#123; ipcMain &#125; = require(&#x27;electron&#x27;); 然后，在渲染进程中向主进程发送消息或者监听主进程发送的消息。我们可以使用ipcRenderer.send方法来向主进程发送消息，并且指定一个channel作为消息类型；我们也可以使用ipcRenderer.on方法来监听主进程发送的消息，并且指定一个channel作为消息类型。例如：123456// 在渲染进程中向主进程发送消息ipcRenderer.send(&#x27;readFileDir&#x27;, &#x27;Hello from vue&#x27;);// 在渲染进程中监听主进程发送的消息ipcRenderer.on(&#x27;readFileDir_status&#x27;, (event, data) =&gt; &#123; console.log(data); // dir from electron&#125;); 接着，在主进程中接收或者发送消息。我们可以使用ipcMain.on方法来接收渲染进程发送的消息，并且指定一个channel作为消息类型；我们也可以使用event.reply方法来向发送消息的渲染进程回复消息，并且指定一个channel作为消息类型。例如：123456// 在主进程中接收渲染进程发送的消息ipcMain.on(&#x27;readFileDir&#x27;, (event, data) =&gt; &#123; console.log(data); // Hello from vue // 在主进程中向发送消息的渲染进程回复消息 event.reply(&#x27;readFileDir_status&#x27;, &#x27;dir from electron&#x27;);&#125;); 相关结论&nbsp;&nbsp;&nbsp;&nbsp;通信的核心原理是基于事件驱动的 相关参考 https://www.electronjs.org/docs/api/ipc-main https://www.electronjs.org/docs/api/ipc-renderer","tags":["electron","vue"]},{"title":"客户端保活最佳方案机制","path":"/posts/2021101220/","content":"更优雅的利用系统机制保活 使用场景一个云控脚本引擎 需求目的需要让程序一直在后台运行保持不被系统杀死 避免让用户在使用过程中还需时刻盯着程序 造成不必要的繁琐问题 以达到配置好相关信息后只需提供设备电量 后续便可不用碰设备 实现远程云控效果 相关问题 这年头还研究保活是想用户设备发热发烫么嗯 从使用场景来看 对用户而言最重要的能够随时接收命令 愿意使用就相当于接受了这一缺点 双进程感觉挺靠谱的 有很多人也推这个保活机制使用场景不同 对用户造成的观感会有很大差别 参考实现音乐类程序例如QQ音乐能一直在后台播放 相关代码 代码区12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class SilentMusicService : Service() &#123; private var mMediaPlayer: MediaPlayer? = null private var mAudioManager: AudioManager? = null private lateinit var notificationBuilder: NotificationCompat.Builder private val mAudioFocusChange: OnAudioFocusChangeListener = object : OnAudioFocusChangeListener &#123; override fun onAudioFocusChange(focusChange: Int) &#123; when (focusChange) &#123; AudioManager.AUDIOFOCUS_GAIN -&gt; &#123; try &#123; startPlayMusic() &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; &#125; AudioManager.AUDIOFOCUS_LOSS -&gt; &#123; mAudioManager!!.abandonAudioFocus(this) &#125; &#125; &#125; &#125; override fun onBind(intent: Intent): IBinder? &#123; throw UnsupportedOperationException(&quot;Not yet implemented&quot;) &#125; @RequiresApi(Build.VERSION_CODES.O) override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int &#123; NotificationUtils.notify(0) &#123; param -&gt; intent.putExtra(&quot;id&quot;, 0) notificationBuilder = param.setSmallIcon(R.mipmap.ic_launcher) .setContentText(R.string.this_is_a_running_foreground_process.toText()) .setAutoCancel(false) .setOngoing(true) &#125; NotificationUtils.cancelAll() startForeground(1, notificationBuilder.notification) mAudioManager = getSystemService(AUDIO_SERVICE) as AudioManager if (mAudioManager != null) mAudioManager!!.requestAudioFocus( mAudioFocusChange, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN ) mMediaPlayer = MediaPlayer.create(applicationContext, R.raw.no_notice) mMediaPlayer?.isLooping = true startPlayMusic() return START_STICKY &#125; private fun startPlayMusic() &#123; if (mMediaPlayer != null &amp;&amp; !mMediaPlayer!!.isPlaying) &#123; mMediaPlayer!!.start() &#125; &#125; private fun stopPlayMusic() &#123; if (mMediaPlayer != null) &#123; mMediaPlayer!!.stop() &#125; &#125; override fun onDestroy() &#123; super.onDestroy() stopPlayMusic() startService(Intent(this, SilentMusicService::class.java)) &#125;&#125; 清单区12345&lt;service android:name=&quot;.service.SilentMusicService&quot; android:priority=&quot;1000&quot; android:enabled=&quot;true&quot; android:process=&quot;:musicService&quot;/&gt; 测试结果 机型品牌 系统版本 成果 HUAWEI 7.0 8.1 9.0 可长时间运转完成任务 Redmi 9.0 10 11 可长时间运转完成任务(10以上添加另外的保活配置) Vivo、OPPO 10 可长时间运转完成任务(测试次数过少)","tags":["android"],"categories":["Android开发游记"]},{"title":"实现一个控件内多处可点击事件","path":"/posts/2021051013/","content":"轻松处理一个控件内多处点击事件 背景需求需要在一个TextView控件内存在两个可点击的事件 思路利用SpannableString实现 重写其updateDrawState方法为false即可 实现先创建SpannableString并使用其Message信息完整范围内容 1SpannableString spannableString = new SpannableString(msg); 创建点击事件 123456789101112ClickableSpan userServiceAgreementClick = new ClickableSpan() &#123; @Override public void onClick(View widget) &#123; //dowork &#125; //当前方法重写取消下划线 @Override public void updateDrawState(@NonNull TextPaint ds) &#123; ds.setColor(ds.linkColor); ds.setUnderlineText(false); &#125; &#125;; 配置点击事件 12345/** * @param userServiceAgreementFirst 指定内容开始下标 * @param userServiceAgreementLast 指定内容结束下标 */spannableString.setSpan(userServiceAgreementClick, privacyPolicyFirst, privacyPolicyLast, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); 配置颜色 1spannableString.setSpan(new ForegroundColorSpan(ContextCompat.getColor(getContext(), R.color.public_color_0289FF)), userServiceAgreementFirst, userServiceAgreementLast, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); 最后配置效果以及内容 12345678/** * @param firstUserXyContext TextView控件实参 * @param setHighlightColor 设置点击效果为透明 * @param setMovementMethod 点击的时候产生超链接*/ firstUserXyContext.setHighlightColor(Color.TRANSPARENT); firstUserXyContext.setText(spannableString); firstUserXyContext.setMovementMethod(LinkMovementMethod.getInstance()); 最终收获SpannableString只允许先设置点击事件然后才能设置色值 否则无效","tags":["android"],"categories":["Android开发游记"]},{"title":"项目初次提交至github过程","path":"/posts/2021012714/","content":"简单记录备用 创建本地 初始化一个空的git仓库 将所有文件添加到暂存区 将暂存区的文件提交到本地仓库 创建远程12git config --global user.name &quot;ymkiux&quot;git config --global user.email &quot;3255284101@qq.com&quot; 配置链接ssh 获取当前生成的ssh 关联仓库 将本地仓库和远程仓库关联起来 查看当前的远程仓库地址 本地=&gt;远程 推送到远程仓库 刷新github网站上的仓库页面即可看到效果 使用branch管理不同product 创建副分支 copy项目到当前路径下然后推送 相关问题1.fatal: remote origin already exists 移除再重新关联库即可2.git push错误failed to push some refs to 本地远程异同3.could not open directory ‘lib/wrapper/****services/‘: Filename too long 2.fatal: sha1 file ‘‘ write error: Broken pipe git config –global http.postBuffer 15728640000 3.ssh:connect to host github.com port 22: Connection timed out 需要在 ~/.ssh/config 文件中覆盖 SSH 设置。使用以下命令编辑该文件： 在文件中添加以下内容： 1234# Add section below to itHost github.com Hostname ssh.github.com Port 443 保存并关闭文件。 12345678:w 保存文件但不退出vim:w file 将修改另外保存到file中，不退出vim:w! 强制保存，不退出vim:wq 保存文件并退出vim:wq! 强制保存文件，并退出vim:q 不保存文件，退出vim:q! 不保存文件，强制退出vim:e! 放弃所有修改，从上次保存文件开始再编辑命令历史 最后，再次尝试使用以下命令进行 SSH 连接： 4.Failed to connect to github.com port 443 after 21082 ms: Timed out1git config --global http.proxy 127.0.0.1:port","tags":["git","github"],"categories":["实用教程"]},{"title":"hexo本地运行端口冲突的解决方法","path":"/posts/2021011016/","content":"FATAL Port 4000 has been used. Try other port instead. 起因起因 这里看到是端口4000被一个进程占用了 方法解决方法 使用cmd命令行执行以下命令1.获取端口对应进程信息 1netstat -ano|findstr 4000 最后一列第一个便是该进程的进程号 2.通过进程号关闭该进程 1taskkill /PID 进程号 /f 结果起因及结果截图 总结总结端口被占用&gt;找到关联进程号&gt;强制停止该进程 - netstat -ano|findstr 被占用的端口号 - taskkill /PID 以上命令获取到的进程号 /f #起因,#方法,#结果,#总结{ display:none; }","tags":["hexo","Windows"],"categories":["Windows"]},{"title":"全局Application实例使用及分析","path":"/posts/2020122822/","content":"简单明了通过源码分析获取其Context对象实例 思考-分析-解决通过Kaede Akatsuki的这篇文章了解到: Application实例在App运行时，始终存在着。 ActivityThread匿名类中存在其实例的值 反射Context对象引用 12345678Object activityThread = null; try &#123; Method method = Class .forName(&quot;android.app.ActivityThread&quot;) .getMethod(&quot;currentActivityThread&quot;); method.setAccessible(true); activityThread = method.invoke(null); &#125; catch (final Exception e) &#123; Log.w(TAG, e);&#125; 其反射对应方法内容 1234@UnsupportedAppUsagepublic static ActivityThread currentActivityThread() &#123; return sCurrentActivityThread;&#125; emmm这里看了源码发现有两个可以直接反射出实例的方法 这里先给出源码 12345@UnsupportedAppUsagepublic static Application currentApplication() &#123; ActivityThread am = currentActivityThread(); return am != null ? am.mInitialApplication : null;&#125; 注意到了没，这里已经将其currentActivityThread方法返回值转化为Application对象实例 那么问题看起来就简单多了 123val method = Class.forName(&quot;android.app.ActivityThread&quot;) .getDeclaredMethod(&quot;currentApplication&quot;)context = method.invoke(null) as Application 至于为什么不使用try catch 两点 正常状态不会抛出异常 调试才会一直抛出 try catch 一旦使用 catch错误类型须写全 否则无法识别 比如这样 12345678910111213try &#123; val method =Class.forName(&quot;android.app.ActivityThread&quot;) .getDeclaredMethod(&quot;currentApplication&quot;) context = method.invoke(null) as Application &#125; catch (e: NoSuchMethodException) &#123; e.printStackTrace() &#125; catch (e: ClassNotFoundException) &#123; e.printStackTrace() &#125; catch (e: IllegalAccessException) &#123; e.printStackTrace() &#125; catch (e: InvocationTargetException) &#123; e.printStackTrace()&#125; 那第二种方法呢? 嗯。直接看源码 123456789@UnsupportedAppUsagepublic ContextImpl getSystemContext() &#123; synchronized (this) &#123; if (mSystemContext == null) &#123; mSystemContext = ContextImpl.createSystemContext(this); &#125; return mSystemContext; &#125; &#125; 这个方法为什么看起来好眼熟 但是不能用哦 ContextImpl这个类是继承Context但是在Android sdk较低版本是未实现的类","tags":["android"],"categories":["Android开发游记"]},{"title":"封装AlertDialog自定义布局","path":"/posts/2020112817/","content":"更轻松解决AlertDialog臃肿自定义实现 思路封装其view方法 通过自定义接口提供给接口使用者进行其相关逻辑的操作 果然接口几乎是万金油的存在 实现123456789101112131415161718fun showAlertDialog(id: Int, confirmCallback: ConfirmCallback): View &#123; var show: AlertDialog? = null val customizeDialog: AlertDialog.Builder = AlertDialog.Builder(context) customizeDialog.setCancelable(false) val infoview: View = LayoutInflater.from(context).inflate( id, null, false ) customizeDialog.setView(infoview) customizeDialog.setPositiveButton( &quot;确定&quot; ) &#123; dialog, which -&gt; confirmCallback.doWork() show!!.dismiss() &#125; show = customizeDialog.show() return infoview &#125; 普通使用1234567891011var id: EditText? = nullval showCustomizeDialog = showAlertDialog(R.layout.iv_activity_user_shared_interface_activity_add_fragment,object : ConfirmCallback &#123; override fun doWork() &#123; if (id!!.text.isEmpty()) &#123; Toast.makeText(this@MainActivity, &quot;内容为空&quot;,Toast.LENGTH_SHORT).show() return &#125; Toast.makeText(this@MainActivity, &quot;测试成功&quot;, Toast.LENGTH_SHORT).show() &#125; &#125;)id = showCustomizeDialog.findViewById&lt;EditText&gt;(R.id.edit_iv_activity_user_shared_interface_activity_add_fragment_id) 注释具体可访问Github","tags":["android"],"categories":["Android开发游记"]},{"title":"实现自定义倒计时View","path":"/posts/2020092918/","content":"更优雅的让TextView实时显示预设倒计时场景 背景项目后台接口已写好，而客户端发送验证码UI逻辑上需要实现类似于倒计时功能 实现初步123456789while (time &gt; 0) &#123; time-- print(&quot;还剩&quot;+ time + &quot;秒&quot;) try &#123; Thread.sleep(1000) &#125; catch (e: InterruptedException) &#123; e.printStackTrace() &#125;&#125; 深入通过Runnable实现1implements Runnable 定义其运行标识以及设定时间12private boolean isRun;private int time=60; 开启及停止12345678public void start() &#123; this.isRun = true; run(); &#125; public void stop() &#123; this.isRun = false; &#125; 自减值12345678private void count() &#123; time--; if (time == 0) &#123; stop(); this.setText(&quot;请重试&quot;); time=60; &#125; &#125; run方法12345678910@Override public void run() &#123; count(); if (isRun) &#123; this.setText(&quot;还剩&quot;+time+&quot;秒&quot;); postDelayed(this, 1000); &#125; else &#123; removeCallbacks(this); &#125; &#125; 调用1tv_fragment_business_settlement_send_verification_code.start() 理解通过标识真假判断是否执行 若执行便自减至0止步 其变化的数量实时显示在自定义控件上 适用于发送验证码功能模块开发","tags":["android"],"categories":["Android开发游记"]},{"title":"自定义Adapter实现无限存余","path":"/posts/2020092523/","content":"继承无限循环adapter 重写实现有限adapter 背景当前已存在符合当前需求的adapter 问题当前存在的adapter为无限循环式 而当前需要显示的仅仅只是其中一部分数据信息 不想直接复制原先ViewHoloder以及onBindView内的数据 思路重写getItemCount()以及onBindViewHolder方法原先ViewHolder类中通过泛型获取控件ID以及通过ID设置文字以及图片等功能 实现继承原适配器 重写方法12345678910111213141516171819202122232425262728public class MLiveAdapter extends LiveAdapter &#123; private List&lt;live&gt; liveList; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; live = liveList.get(position); holder.setImageRes(R.id.iv_live_icon, live.getImageId()); //省略... holder.setText(R.id.tv_live_trade_name, live.getTradeName()); holder.getView(R.id.l1_live_bg).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //省略... &#125; &#125;); super.onBindViewHolder(holder, position); &#125; public MLiveAdapter(List&lt;live&gt; liveList) &#123; super(liveList); this.liveList = liveList; &#125; @Override public int getItemCount() &#123; return liveList.size(); &#125;&#125; 获取ID 设置文字以及图片12345678910111213141516171819202122232425262728293031323334353637383940protected static class ViewHolder extends RecyclerView.ViewHolder &#123; ImageView image; TextView TradeName; LinearLayout liBg; View mConvertView; //省略... SparseArray&lt;View&gt; mViews; public ViewHolder(View view) &#123; super(view); //省略... image = view.findViewById(R.id.iv_live_icon); TradeName = view.findViewById(R.id.tv_live_trade_name); liBg = view.findViewById(R.id.l1_live_bg); mViews = new SparseArray&lt;View&gt;(); mConvertView=view; &#125; public &lt;T extends View&gt; T getView(int viewId) &#123; View view = mViews.get(viewId); if (view == null) &#123; view = mConvertView.findViewById(viewId); mViews.put(viewId, view); &#125; return (T) view; &#125; public ViewHolder setText(int viewId, String text) &#123; TextView tv = getView(viewId); tv.setText(text); return this; &#125; public ViewHolder setImageRes(int viewID, int resId) &#123; ImageView iv = getView(viewID); iv.setImageResource(resId); return this; &#125;&#125; 最后泛型真的很强大SparseArray类有着增删改查的功能","tags":["android"],"categories":["Android开发游记"]},{"title":"系统剪贴板的标准式使用","path":"/posts/2020092317/","content":"更便捷使用系统剪切板功能 类解ClipboardManager： 表示一个剪贴板管理器ClipData： 剪贴板中保存的所有剪贴数据集ClipData.Item： 剪贴数据集中的一个数据条目 复制内容内容为obj.toString() 1234val clipboard=requireActivity().getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManagerclipboard.text = obj.toString().trim(&#123; it &lt;= &#x27; &#x27; &#125;)val clipData = ClipData.newPlainText(null, obj.toString())clipboard.setPrimaryClip(clipData) 获取系统剪贴板内容12345678910111213141516171819ClipboardManager manager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); if (manager != null) &#123; if (manager.hasPrimaryClip() &amp;&amp; manager.getPrimaryClip().getItemCount() &gt; 0) &#123; CharSequence charSequence_addedText = manager.getPrimaryClip().getItemAt(0).getText(); String addedTextString = String.valueOf(charSequence_addedText); try &#123; JSONObject obj = new JSONObject(addedTextString); JSONArray scanner = obj.getJSONArray(&quot;scanner&quot;); StringBuffer stringBuffer_scanner = new StringBuffer(); for (int i = 0; i &lt; scanner.length(); i++) &#123; String s = (String) scanner.get(i); stringBuffer_scanner.append(s); &#125; tvFragXsScanner.setText(stringBuffer_scanner.toString()); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 清空剪贴板内容123456789ClipboardManager manager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); if (manager != null) &#123; try &#123; manager.setPrimaryClip(manager.getPrimaryClip()); manager.setText(null); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 参考Android官方文档复制和粘贴","tags":["android"],"categories":["Android开发游记"]},{"title":"实现单个activity加载多个fragment","path":"/posts/2020091813/","content":"更轻松以及简化activity使用 思路由另一个界面跳转到当前activity时,携带参数值用来判断本次跳转加载哪个碎片事件 实现这里通过intent传值 12345val intent = Intent(this@SettingActivity, FeedbackActivity::class.java) intent.putExtra(&quot;Fragment&quot;, 0) startActivity(intent) overridePendingTransition(0, 0) finish() 当前activity接收加载碎片事件 1234567891011121314151617private val userFeedbackFragment = UserFeedbackFragment()private val bugFeedbackFragment = BugFeedbackFragment()val intExtra = intent.getIntExtra(&quot;Fragment&quot;, 0) when (intExtra) &#123; 0 -&gt; &#123; supportFragmentManager .beginTransaction() .add(R.id.frag_feed, userFeedbackFragment, null) .commit() &#125; 1 -&gt; &#123; tv_feed_title.text = getString(R.string.bug_feedback) supportFragmentManager .beginTransaction() .add(R.id.frag_feed, bugFeedbackFragment, null) .commit() &#125; 描述通过intExtra接收值判断加载设定碎片的加载事件","tags":["android"],"categories":["Android开发游记"]},{"title":"便捷式时间差零","path":"/posts/2020091615/","content":"轻松解决时间差问题 背景项目需要显示发布的内容与当前时间差值 实现当前时间12345678/** * @return 返回当前时间 */public String getTime() &#123; Date date = new Date(); @SuppressLint(&quot;SimpleDateFormat&quot;) SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); return dateFormat.format(date);&#125; 旧版时间差12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 返回时间差 * * @param currTime 当前时间 * @param releaseTime 接口获取的时间 * @return */public String getTimeDifference(String currTime, String releaseTime) throws ParseException &#123; DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d1 = dateFormat.parse(currTime); Date d2 = dateFormat.parse(releaseTime); long diff = d1.getTime() - d2.getTime(); long days = diff / (1000 * 60 * 60 * 24); long hours = (diff - days * (1000 * 60 * 60 * 24)) / (1000 * 60 * 60); long minutes = (diff - days * (1000 * 60 * 60 * 24) - hours * (1000 * 60 * 60)) / (1000 * 60); String s = days + &quot;天&quot; + hours + &quot;小时&quot; + minutes + &quot;分&quot;; if (days != 0 &amp;&amp; hours != 0 &amp;&amp; minutes != 0) &#123; return s; &#125; if (days != 0) &#123; if (hours != 0) &#123; if (minutes != 0) &#123; return s; &#125; else &#123; return s.replace(minutes + &quot;分&quot;, &quot;&quot;); &#125; &#125; else &#123; s = s.replace(hours + &quot;小时&quot;, &quot;&quot;); if (minutes != 0) &#123; return s; &#125; else &#123; return s.replace(minutes + &quot;分&quot;, &quot;&quot;); &#125; &#125; &#125; else &#123; s = s.replace(days + &quot;天&quot;, &quot;&quot;); if (hours != 0) &#123; if (minutes != 0) &#123; return s; &#125; else &#123; return s.replace(minutes + &quot;分&quot;, &quot;&quot;); &#125; &#125; else &#123; s = s.replace(hours + &quot;小时&quot;, &quot;&quot;); if (minutes != 0) &#123; return s; &#125; else &#123; return s.replace(minutes + &quot;分&quot;, &quot;&quot;); &#125; &#125; &#125;&#125; 新版时间差1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 返回时间差 * * @param currTime 当前时间 * @param releaseTime 接口获取的时间 * @return */ public String getTimeDifference(String currTime, String releaseTime) throws ParseException &#123; DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d1 = dateFormat.parse(currTime); Date d2 = dateFormat.parse(releaseTime); long diff = d1.getTime() - d2.getTime(); long days = diff / (1000 * 60 * 60 * 24); long hours = (diff - days * (1000 * 60 * 60 * 24)) / (1000 * 60 * 60); long minutes = (diff - days * (1000 * 60 * 60 * 24) - hours * (1000 * 60 * 60)) / (1000 * 60); String s = days + &quot;天&quot; + hours + &quot;小时&quot; + minutes + &quot;分&quot;; if (days != 0 &amp;&amp; hours != 0 &amp;&amp; minutes != 0) &#123; return s; &#125; if (days != 0) &#123; return getTime(hours, minutes, s); &#125; else &#123; s = s.replace(days + &quot;天&quot;, &quot;&quot;); return getTime(hours, minutes, s); &#125; &#125; private String getTime(long hours, long minutes, String s) &#123; if (hours != 0) &#123; if (minutes != 0) &#123; return s; &#125; else &#123; return s.replace(minutes + &quot;分&quot;, &quot;&quot;); &#125; &#125; else &#123; s = s.replace(hours + &quot;小时&quot;, &quot;&quot;); if (minutes != 0) &#123; return s; &#125; else &#123; return s.replace(minutes + &quot;分&quot;, &quot;&quot;); &#125; &#125; &#125;&#125; 效果$days+&quot;天&quot;+$hours+&quot;小时&quot;+$minutes+&quot;分&quot;","tags":["android"],"categories":["Android开发游记"]},{"title":"webview隐藏网页元素","path":"/posts/2020091517/","content":"更优雅实现webview元素隐藏显示 背景因为百度开发者账号遗失,所以才想到之前用石墨文档写过类似的内容,整理一下 实现自定义类继承webview重写onDraw方法 12345678910111213141516171819202122232425262728293031public class H5WebView extends WebView &#123; public H5WebView(Context context) &#123; super(context); &#125; public H5WebView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public H5WebView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mOnDrawListener != null) &#123; mOnDrawListener.onDrawCallBack(); &#125; &#125; private OnDrawListener mOnDrawListener; public void setOnDrawListener(OnDrawListener onDrawListener) &#123; mOnDrawListener = onDrawListener; &#125; public interface OnDrawListener &#123; public void onDrawCallBack(); &#125;&#125; 定义JavaScript避免繁琐 封装为函数 12345678//元素块有idprivate fun Hide_id_Elements(string: String) &#123; val javascript = (&quot;javascript:function hideId() &#123; &quot; + &quot;document.getElementById(\\&quot;$string\\&quot;).style.display =\\&quot;none\\&quot;&quot; + &quot;&#125;&quot;) web_xs_petReleaseAddress.loadUrl(javascript) web_xs_petReleaseAddress.loadUrl(&quot;javascript:hideId();&quot;) &#125; 12345678//元素块只有classprivate fun Hide_class_Elements(string: String) &#123; val javascript = (&quot;javascript:function hideClass() &#123; &quot; + &quot;document.getElementsByClassName(\\&quot;$string\\&quot;)[0].style.display =\\&quot;none\\&quot;&quot; + &quot;&#125;&quot;) web_xs_petReleaseAddress.loadUrl(javascript) web_xs_petReleaseAddress.loadUrl(&quot;javascript:hideClass();&quot;) &#125; 12345678910111213//隐藏方法private fun hideE() &#123; try &#123; Hide_id_Elements(&quot;tool-container&quot;) Hide_id_Elements(&quot;message-center&quot;) Hide_id_Elements(&quot;user-center&quot;) Hide_id_Elements(&quot;newuilogo&quot;) Hide_class_Elements(&quot;BMap_cpyCtrl BMap_noprint anchorBL&quot;) Hide_class_Elements(&quot;mapTypeCard panorama choosedType&quot;) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; &#125; 调用web_xs_petReleaseAddress为webview 123web_xs_petReleaseAddress.setOnDrawListener(H5WebView.OnDrawListener &#123; hideE()&#125;) 注意document.getElementsByClassName拿到的是数组并非某一个对象 可从console控制台测试看出","tags":["android","webview"],"categories":["Android开发游记"]},{"title":"上传本地图片到服务器详解","path":"/posts/2020091113/","content":"通过思路实现上传服务器逻辑 思路 回调图片path并解码为bitmap将得到的bitmap通过base64格式转化为字符串通过服务器对应接口get/post 参数携带其字符串 实现回调解码 bitmap为解码位图 imgPath为回调path 123456789101112131415161718192021222324252627282930313233private String imgPath;private Bitmap bitmap;public void loadImage() &#123; //调用相册中选择图片 Intent galleryIntent = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI); startActivityForResult(galleryIntent, RESULT_LOAD_IMG); &#125; //返回被选择图片结果 @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); try &#123; if (requestCode == RESULT_LOAD_IMG &amp;&amp; resultCode == RESULT_OK &amp;&amp; null != data) &#123; Uri selectedImage = data.getData(); String[] filePathColumn = &#123;MediaStore.Images.Media.DATA&#125;; // 获取游标 Cursor cursor = getContentResolver().query(selectedImage, filePathColumn, null, null, null); cursor.moveToFirst(); int columnIndex = cursor.getColumnIndex(filePathColumn[0]); imgPath = cursor.getString(columnIndex); cursor.close(); imXsFirstImage.setVisibility(View.VISIBLE); bitmap = BitmapFactory.decodeFile(imgPath); imXsFirstImage.setImageBitmap(bitmap); &#125; else &#123; L.t(getResources().getString(R.string.You_havenot_picked_Image)); &#125; &#125; catch (Exception e) &#123; L.t(getResources().getString(R.string.Something_went_wrong)); &#125; &#125; bitmap与base64互转位图转为字符串123456789101112/** * 将bitmap转为base64字符串 * @param bitmap bitmap位图 * @param quality 80表示压缩掉20% * @return base64字符串 */ public String TurnBitmapBase(Bitmap bitmap) &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.JPEG, 80, bos); byte[] bytes = bos.toByteArray(); return Base64.encodeToString(bytes, Base64.DEFAULT); &#125; 字符串转为位图123456789101112131415/** * 将base64字符串转为bitmap位图 * @param base_bitmap 服务端回调base64字符串 * @return bitmap位图 */ public Bitmap TurnBaseBitmap(String base_bitmap) &#123; byte[] byteIcon = Base64.decode(base_bitmap, Base64.DEFAULT); for (int i = 0; i &lt; byteIcon.length; ++i) &#123; if (byteIcon[i] &lt; 0) &#123; byteIcon[i] += 256; &#125; &#125; Bitmap bitmap = BitmapFactory.decodeByteArray(byteIcon, 0, byteIcon.length); return bitmap; &#125; ​ 字符串转为位图: 运用于通过服务器接口将其获取到的值通过其进行转码为位图 便于显示​ 位图转为字符串: 运用于将其数据通过接口传值(我这边用的是数据库表存 方便上传之后 客户端还可以显示其内容)","tags":["android","java"],"categories":["Android开发游记"]},{"title":"无限循环RecyclerView的完美方案","path":"/posts/2020091016/","content":"无限循环RecyclerView 背景 当前服务端直播接口数量太少 所以想到这个方法 方法参数取余运算 getItemCount长度无限 1234@Overridepublic int getItemCount() &#123;\treturn Integer.MAX_VALUE;&#125; onBindViewHolder() 方法里对position参数取余运算 123456@Overridepublic void onBindViewHolder(ViewHolder holder, int position) &#123; int index = position % liveList.size(); ...&#125; 细节 liveList.size为旧getItemCount方法返回值 index为新的position与bean类get对应值","tags":["android"],"categories":["Android开发游记"]},{"title":"SensorEventListener接口实现摇一摇功能","path":"/posts/2019071920/","content":"更优雅的实现摇一摇功能 定义参数123private long lastUpdate = 0;private float last_x, last_y, last_z;private static final int SHAKE_THRESHOLD = 600; 重写重力感应方法12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void onSensorChanged(SensorEvent sensorEvent) &#123; Sensor mySensor = sensorEvent.sensor; if (mySensor.getType() == Sensor.TYPE_ACCELEROMETER) &#123; float x = sensorEvent.values[0]; float y = sensorEvent.values[1]; float z = sensorEvent.values[2]; long curTime = System.currentTimeMillis(); if ((curTime - lastUpdate) &gt; 100) &#123; long diffTime = (curTime - lastUpdate); lastUpdate = curTime; float speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000; if (speed &gt; SHAKE_THRESHOLD) &#123; if (isForeground(MainActivity.this, &quot;MainActivity&quot;)) &#123; Intent intent = new Intent(MainActivity.this, AboutActivity.class); startActivity(intent); finish(); overridePendingTransition(R.anim.fade_in, R.anim.fade_out); &#125; &#125; last_x = x; last_y = y; last_z = z; &#125; &#125;&#125;@Overridepublic void onAccuracyChanged(Sensor sensor, int i) &#123;&#125; 利用抽象类实现接口123SensorManager senSensorManager =(SensorManager)getSystemService(Context.SENSOR_SERVICE); Sensor senAccelerometer = senSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); senSensorManager.registerListener(this, senAccelerometer, SensorManager.SENSOR_DELAY_NORMAL); 注意细节 抽象类 该抽象类接口通过继承子类的implement SensorEventListener来实现 清单权限 重力加速度感知权限 android.hardware.sensor.accelerometer","tags":["android"],"categories":["Android开发游记"]},{"title":"利用Snackbar实现双重退出提示信息","path":"/posts/2019070123/","content":"更优雅的实现退出提示信息 定义参数123private Timer tExit;private static Boolean isExit = false;private static final String TAG_EXIT = &quot;exit&quot;; 定义提示信息方法123456789private void showSnackBar(View view, String text) &#123; if (snackbar == null) &#123; snackbar = Snackbar.make(view, text, Snackbar.LENGTH_SHORT); &#125; else &#123; snackbar.setText(text); snackbar.setDuration(Snackbar.LENGTH_SHORT); &#125; snackbar.show(); &#125; 复写onKeyDown方法1使用快捷键ctrl+o 快速找到其方法并生成对应方法以及内容 于方法内写入以下事件 1234567891011121314151617181920if (keyCode == KeyEvent.KEYCODE_BACK) &#123; tExit = null; if (!isExit) &#123; isExit = true; // 准备退出 showSnackBar(titleBar, getString(R.string.click_exit)); tExit = new Timer(); tExit.schedule(new TimerTask() &#123; @Override public void run() &#123; isExit = false; // 取消退出 &#125; &#125;, 2000); &#125; else &#123; Intent intent = new Intent(this, MainActivity.class); intent.putExtra(MainActivity.TAG_EXIT, true); startActivity(intent); &#125; return true; &#125; 注意细节 启动模式 在Androidmanifest清单文件中为所需activity设置android:launchMode=”singleTask” titleBar参数 其实只是我一个自定义标题栏参数","tags":["android"],"categories":["Android开发游记"]},{"title":"博客恢复配置实现git重传","path":"/posts/2019062122/","content":"更轻松的恢复基于hexo博客的重构方法 环境的搭建安装hexo框架1npm install -g hexo 此处可能存在卡死现象 通过config命令换源解决 1npm config set registry http://registry.cnpmjs.org 安装成功如图 本地与GitHub通过git进行桥接配置用户名与邮箱12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 成功后如图配置ssh 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 成功后如图复制ssh至剪切板内 1clip &lt; ~/.ssh/id_rsa.pub 进入账户设置-ssh key设置-添加新ssh并保存 测试连接是否成功1ssh -T git@github.com 成功表现如图 配置项目上传插件博客文件夹下执行 1npm install hexo-deployer-git --save 成功表现如图博客文件夹下执行 1hexo g -d 成功表现如图 本地预览1hexo server -d","tags":["node.js","hexo","git"],"categories":["实用教程"]},{"title":"有关github无法访问","path":"/posts/2019061323/","content":"更优雅的解决有关github网站无法访问问题 详细步骤修改本地的hosts Linux下路径：/etc/hosts windows下路径：C:\\Windows\\System32\\drivers\\etc\\hosts IP在线测速 https://www.ipip.net/ip.html 搜索github.com、github.io 找到响应最快的ip 打开hosts文件 把这个ip代理依照以下格式填进去 hosts使用格式 66.249.89.104 github.com13.229.188.59 github.com185.199.109.153 github.io","tags":["hosts"],"categories":["Windows"]},{"title":"编写雪花js特效无显示","path":"/posts/2019061218/","content":"原因、效果代码以及解决方法 原因webview控件未设置启动js 效果代码定义js事件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script&gt; //获取屏幕宽高 var windowWidth = window.screen.width; var windowHeight = window.screen.height; //创建雪花 function createSnow()&#123; var left = 0; var top = 0; //定义一个初始化随机数,使雪花在屏幕中 var left_random = Math.random() * windowWidth; var top_random = Math.random()* windowHeight; var div = document.createElement(&#x27;div&#x27;); div.className = &#x27;snow&#x27;; div.style.transform = &#x27;scale(&#x27;+(Math.random())+&#x27;)&#x27; document.body.appendChild(div); //雪花飘落 setInterval(function () &#123; div.style.left = left_random + left +&#x27;px&#x27;; div.style.top = top_random + top +&#x27;px&#x27; left += 0.2; top += 0.2; //如果雪花跑到屏幕外面了,让雪花重新返回屏幕顶部 if(left_random + left &gt;= windowWidth)&#123; left_random = Math.random(); left = 0; &#125; if(top_random + top &gt;= windowHeight)&#123; top_random = Math.random(); top = 0; &#125; &#125;,10) &#125; for(var i = 0 ; i &lt; 200 ; i++)&#123; createSnow() &#125;&lt;/script&gt; 定义css1234567.snow&#123; background: white; position: absolute; width: 20px; height: 20px; border-radius: 50%; &#125; 解决方法 webview使用mWebView参数绑定id 12mWebView.getSettings().setJavaScriptEnabled(true); //启用jsmWebView.getSettings().setBuiltInZoomControls(true);//启用缩放","tags":["android","javascript"],"categories":["Android开发游记"]},{"title":"运行古老项目或者他人项目时常遇bug","path":"/posts/2019060919/","content":"更优雅的解决问题 导入项目错误出现“Plugin with id ‘com.android.application’ not found.” 表示需要以“Import Module”的形式导入： 依次选择菜单“File”——“New”——“New Project”，按提示新建一个项目（即Project）； 项目创建完毕，再依次选择菜单“File”——“New”——“Import Module”，按提示导入具体的demo；注意要出现Project级别的build.gradle才可以正常编译。","tags":["android"],"categories":["Android开发游记"]},{"title":"linux下通过git连接github","path":"/posts/2019042722/","content":"Ubuntu下搬砖 安装gitSudo apt-get install git 配置环境Git config --global user.name &quot;github的用户名&quot; Git config --global user.email &quot;github的邮箱&quot; 配置本地ssh密匙ssh-keygen -t rsa -C &quot;github的邮箱&quot; 从配置完本地ssh密匙之后可一直点击enter按键，直到出现 The key&#39;s randomart image is:×××××××××× 注意:在这句代码之前的Generating public/private rsa key pair.Enter file in which to save the key ((这个目录是随机的如果提前就在root权限下配置的便为固定目录)root/.ssh/id_rsa) 便切换到那个目录/.ssh下：Cd /root/.ssh/ 获取密匙并存入通过Git bash输入： cat id_rsa.pub 获取的字符一个不少的复制到github已登录状态下的设置里的ssh和gpg的密匙在ssh keys新创建一个文件 标题测试随意填(这个不影响连接使用) 其下密匙直接将刚刚复制下来的获取源一个不漏的粘贴 保持就好了 继续输入：ssh -T git@github.com 回车即可 若在日志看到 You’ve successfully authenticated, but GitHub does not provide shell access.则表明连接成功.","tags":["linux","git","github"],"categories":["Linux"]},{"title":"四种点击事件","path":"/posts/2019042705/","content":"更优雅实现点击监听事件 简略说明①通过ID②通过内部类实现③通过匿名内部类实现④通过主类点击接口实现 具体实现内部类绑定控件1Button btn=findViewById(R.id.test); 设置监听1btn.setOnClickListener(new MyOnclick()); 为事件实现添加内部类12345678 private class MyOnclick implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; //点击之后的业务逻辑System.out.println(&quot;测试点击事件显示在日志上&quot;);//为了从日志上看点击是否正常运转，写业务逻辑时看具体需求 &#125; &#125; 匿名内部类绑定控件123456789 Button btn=findViewById(R.id.test);###### 设置监听 btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //点击之后的业务逻辑 System.out.println(&quot;测试点击事件显示在日志上&quot;);//为了从日志上看点击是否正常运转，写业务逻辑时看具体需求 &#125; &#125;); 通过主类点击接口实现绑定控件1Button btn=findViewById(R.id.test); 设置接口类型 在实现活动类中implements OnClickListener实现点击事件 点击监听1234 public void onClick(View v) &#123; //点击之后的业务逻辑 System.out.println(&quot;测试点击事件显示在日志上&quot;);//为了从日志上看点击是否正常运转，写业务逻辑时看具体需求&#125;","tags":["android"],"categories":["Android开发游记"]},{"title":"监听式跳转","path":"/posts/2019042520/","content":"更优雅的处理Popupwindow监听 使用一个例子来解决问题 简略操作①创建EMPTY ACTIVITY②将新类继承PopupWindow③定义布局控件以及定义View视图弹窗参数④为窗体内控件点击事件作方法重写式监听⑤于处显示窗体活动下为弹出窗口实现监听类⑥在活动布局下创建显示窗体区域控件⑦实例化之前定义的窗体类并通过其参数回馈监听方法 具体代码定义View视图弹窗参数1private View mMenuView 实例化LayoutInflater对象并传参12LayoutInflater inflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); 为定义弹窗绑定视图布局1234567891011121314151617181920212223242526 mMenuView = inflater.inflate(R.layout.布局名, null);###### 为控件点击事件作监听 btn_dchu.setOnClickListener(itemsOnClick);###### 为弹出窗口实现监听类 private View.OnClickListener itemsOnClick = new View.OnClickListener() &#123; public void onClick(View v) &#123; menuWindow.dismiss(); switch (v.getId()) &#123; case ID: Intent intent = new Intent(); intent.setClass(MainActivity.this,EditActivity.class); startActivity(intent); finish(); break; case ID: Intent intent1 = new Intent(); intent1.setClass(MainActivity.this,AboutActivity.class); startActivity(intent1); finish(); break; default: break; &#125; &#125; &#125;; 为弹窗实例化以达到方法1menuWindow = new SelectPicPopupWindow(MainActivity.this, itemsOnClick); 为窗体通过ID显示绑定控件1menuWindow.showAtLocation(MainActivity.this.findViewById(R.id.main), Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL, 0, 0); //设置layout在PopupWindow中显示的位置","tags":["android"],"categories":["Android开发游记"]},{"title":"重装系统PE启动项无变化","path":"/posts/2019042222/","content":"使用命令行解决 使用USM修复 当前任意PE软件皆可实现以下操作： 当前不在少数还是使用的是家庭版系统，其安装软件限制太高 在几台家庭版笔记本电脑上测试过PE装机，发现类似于大白菜U盘等工具点击运行时总弹出管理员已阻止此应用那种环境下正常运行 测试过网上通过本地策略关闭警告,过程是系统为win10家庭版不存在本地策略，通过一些资料生成本地策略之后关闭警告，结果毫无用处 推荐USM魔术师工具这款应用 正常运行在家庭版系统的PE工具可不多见 载入PE 有无ESP分区 打开dg工具,看看是否存在esp分区,如果不存在则新建一个esp分区之后保存它会自动提示格式化esp分区,确定就行 指派盘区 找到刚刚创建的esp分区点击鼠标右键,选择指派新的驱动器号例如我当时将esp分区指派到d盘之后确认保存 创建引导加载 然后打开pe上的命令提示符(就是那个常见的cmd图标)输入： bcdboot e:\\Windows /s d: /f uefi /l zh-cn 命令回车看到已成功创建启动文件就行了 注意： e:\\Windows 表示之前刻录系统的盘区d: 表示之前创建esp分区盘名 适用性 该方法仅亲测于支持efi模式的电脑","tags":["Windows"],"categories":["Windows"]},{"title":"开发自定义titlebar","path":"/posts/2019042113/","content":"这可以让自定义titlebar变得更简单 首先隐藏系统自带titlebar12requestWindowFeature(Window.FEATURE_NO_TITLE);//remove title bar 即隐藏标题栏getSupportActionBar().hide();// 隐藏ActionBar 创建自定义titlebar类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 1.第一步：定义的类要继承ViewGroup然后监听点击事件(因为自定义titlebar常常为其内到菜单事件作点击交互) 2.第二步：定义显示大小参数以及控件变量名 3.第三步: 定义参数方法以便后期调用 private static final int DEFAULT_MAIN_TEXT_SIZE = 18; private static final int DEFAULT_SUB_TEXT_SIZE = 12; private static final int DEFAULT_ACTION_TEXT_SIZE = 15; private static final int DEFAULT_TITLE_BAR_HEIGHT = 48; private static final String STATUS_BAR_HEIGHT_RES_NAME = &quot;status_bar_height&quot;; private TextView mLeftText; private LinearLayout mRightLayout; private LinearLayout mCenterLayout; private TextView mCenterText; private TextView mSubTitleText; private View mCustomCenterView; private View mDividerView; private boolean mImmersive; private int mScreenWidth; private int mStatusBarHeight; private int mActionPadding; private int mOutPadding; private int mActionTextColor; private int mHeight; public TitleBar(Context context) &#123; super(context); init(context); &#125; public TitleBar(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public TitleBar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; if (mImmersive) &#123; mStatusBarHeight = getStatusBarHeight(); &#125; mActionPadding = dip2px(5); mOutPadding = dip2px(8); mHeight = dip2px(DEFAULT_TITLE_BAR_HEIGHT); initView(context); &#125; private void initView(Context context) &#123; mLeftText = new TextView(context); mCenterLayout = new LinearLayout(context); mRightLayout = new LinearLayout(context); mDividerView = new View(context); LayoutParams layoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT); mLeftText.setTextSize(DEFAULT_ACTION_TEXT_SIZE); mLeftText.setSingleLine(); mLeftText.setGravity(Gravity.CENTER_VERTICAL); mLeftText.setPadding(mOutPadding + mActionPadding, 0, mOutPadding, 0); mCenterText = new TextView(context); mSubTitleText = new TextView(context); mCenterLayout.addView(mCenterText); mCenterLayout.addView(mSubTitleText); mCenterLayout.setGravity(Gravity.CENTER); mCenterText.setTextSize(DEFAULT_MAIN_TEXT_SIZE); mCenterText.setSingleLine(); mCenterText.setGravity(Gravity.CENTER); mCenterText.setEllipsize(TextUtils.TruncateAt.END); mSubTitleText.setTextSize(DEFAULT_SUB_TEXT_SIZE); mSubTitleText.setSingleLine(); mSubTitleText.setGravity(Gravity.CENTER); mSubTitleText.setEllipsize(TextUtils.TruncateAt.END); mRightLayout.setPadding(mOutPadding, 0, mOutPadding, 0); addView(mLeftText, layoutParams); addView(mCenterLayout); addView(mRightLayout, layoutParams); addView(mDividerView, new LayoutParams(LayoutParams.MATCH_PARENT, 1)); &#125;public void setDividerColor(int color) &#123; mDividerView.setBackgroundColor(color); &#125; @Override public void onClick(View view) &#123; final Object tag = view.getTag(); if (tag instanceof Action) &#123; final Action action = (Action) tag; action.performAction(view); &#125; &#125; public View addAction(Action action) &#123; final int index = mRightLayout.getChildCount(); return addAction(action, index); &#125; /** * Adds a new &#123;@link Action&#125; at the specified index. * @param action the action to add * @param index the position at which to add the action */ public View addAction(Action action, int index) &#123; LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT); View view = inflateAction(action); mRightLayout.addView(view, index, params); return view; &#125; public void setTitle(int resid) &#123; setTitle(getResources().getString(resid)); &#125; public void setTitleColor(int resid) &#123; mCenterText.setTextColor(resid); &#125; public void setSubTitleColor(int resid) &#123; mSubTitleText.setTextColor(resid); &#125; private void setTitle(CharSequence title, CharSequence subTitle, int orientation) &#123; mCenterLayout.setOrientation(orientation); mCenterText.setText(title); mSubTitleText.setText(subTitle); mSubTitleText.setVisibility(View.VISIBLE); &#125; public void setHeight(int height) &#123; mHeight = height; setMeasuredDimension(getMeasuredWidth(), mHeight); &#125; 在所需布局文件中引入自定义titlebar1234567例如： &lt;zut.edu.cn.notepad.UI.TitleBar android:id=&quot;@+id/title_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&quot;zut.edu.cn.notepad&quot;为我那个安卓项目的包名&quot;UI&quot;为自定义的Titlebar类所处路径的文件夹&quot;TitleBar&quot;为自定义titlebar的类名 在其onCreate内定义沉浸式123456789101112131415161718 boolean isImmersive = false;if (hasKitKat() &amp;&amp; !hasLollipop()) &#123;isImmersive = true;//透明状态栏getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);//透明导航栏// getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);&#125; else if (hasLollipop()) &#123;Window window = getWindow();window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS| WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN// | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION| View.SYSTEM_UI_FLAG_LAYOUT_STABLE);window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);window.setStatusBarColor(Color.TRANSPARENT);isImmersive = true;&#125; 绑定titlebar并赋值123456789final TitleBar titleBar = (TitleBar) findViewById(R.id.title_bar);titleBar.setImmersive(isImmersive);titleBar.setBackgroundColor(Color.parseColor(&quot;#64b4ff&quot;));titleBar.setLeftImageResource(R.mipmap.back_green);titleBar.setLeftText(&quot;返回&quot;);titleBar.setLeftTextColor(Color.WHITE);","tags":["android"],"categories":["Android开发游记"]},{"path":"/about/index.html","content":"编程不易，易者不编文章友链工具关于 建站历程2023.04.051.5.2=&gt;1.18.52021.02.27从Volantis迁移至Stellar主题2020.12.24对部分插件源码进行优化逻辑处理2019.04.15从NexT迁移至Volantis主题2019.01.23基于NexT主题部署环境 关于昵称：Ymkiux兴趣：ACG、尤克里里、程序设计、小说片段编写、剪辑理念：为了减少错误、重复、杂乱的文章再次覆盖网络知识体系而存在的佛系小站"},{"title":"分类","path":"/categories/index.html","content":""},{"path":"/friends/index.html","content":"编程不易，易者不编文章友链工具关于 姜姜酱parade岁月Kaede Akatsuki不想吃泡面扔物线Flywith24ManjusakaPdoneHoubb若葉葱苓 柠檬味儿的咖啡FeanChengsceext2 以上友链均已授权"},{"path":"/tools/index.html","content":"编程不易，易者不编文章友链工具关于 UINaiveUI IconIconfont XIcon RegularStack Regex101 MKLab GoRegex ComparatorJsonComparator TextComparator ConverterCssPack CssToStyl ConvertToBase64 CompressToOneLine Vue3RenderEscape CamelcaseConverter convertBackslashToForward AnalysisWordCount Media ProcessingRemoveBg RemoveBg1 MatchColors ImageOverscore OtherJsRun CssSearch RandomStr TrafficDisappears YouTubeDownload ImageEnlargement SvgToVectorDrawable"},{"title":"便笺","path":"/notes/index.html","content":"TOC便笺undefinedAndroid 相关问题Android 相关问题Java 相关问题Java 相关问题"},{"path":"/notes/Android/index.html","content":"相关编译错误Error running app：Default Activity not found在任务清单内为活动注册事件 1234567&lt;activity android:name=&quot;.SpalshActivity&quot; android:label=&quot;&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 提示Installation failed 检查包名是否存在大写字母,改为小写字母即可 检查setting下的build内install run第一选择是否被选中,若此则取消选中,然后保存即可 Unable to find optional library: org.apache.http.legacyHttpClient已经在API 23中删除在相应的module下的build.gradle中加入即可 123android &#123; useLibrary &#x27;org.apache.http.legacy&#x27;&#125; org.gradle.api.GradleException: Lint found fatal errors while assembling a release target 日志详情123456789org.gradle.api.GradleException: Lint found fatal errors while assembling a release target.To proceed, either fix the issues identified by lint, or modify your build script as follows:android &#123;lintOptions &#123;checkReleaseBuilds false// Or, if you prefer, you can continue to check for errors in release builds,// but continue the build even when errors are found:abortOnError false &#125;&#125; 原因分析Lint在编译release包的时候发现了致命的错误。 解决方法方法一：为了继续编译或解决Lint标记的问题，或许应该对你的构建脚本进行如下的改动，即在app主module的build.gradle里增加lintOptions，其中checkReleaseBuilds false表示在进行Release构建时不再进行Lint检查，abortOnError false则表示检查到错误后继续编译，不取消当前的构建任务。 1234lintOptions&#123; checkReleaseBuilds false abortOnError false &#125; 方法二：通过release编译打包时的编译打印日志内容中错误提示信息跳转对应布局文件中解决问题 Error message “Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8”Gradle JDK选择11 version 11.0.8/opt/android-studio-canaryl/jre即可 Caused by: java.lang.IllegalArgumentException: The given artifact contains a string literal with a package reference ‘android.support.v4.content’ that cannot be safely rewritten 原因support.v4库未找到Androidx支持类型 解决方法12345//引入ButterKnifeimplementation&quot;com.jakewharton:butterknife:10.0.0&quot;kapt &quot;com.jakewharton:butterknife-compiler:10.0.0&quot;//抽取功能组件apply plugin: &#x27;kotlin-kapt&#x27; 相关运行异常net::ERR_CLEARTEXT_NOT_PERMITTED 原因Android9.0以上无法直接加载http 多种解决方法一. application节点添加 二. targetSdkVersion 降级回至27三. 创建xml新建network_security_config在清单文件的application标签添加配置 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt; 四. 服务器和本地应用都改用 https The style on this component requires your app theme to be Theme.AppCompat (or a descendant).在引用这个自定义布局的界面根标签里，添加一行代码 Failure delivering result ResultInfo{. }to activity java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState 原因activity不可见时不执行数据文件传值操作 解决方法通过趣味问题的第一点解决 让这种逻辑处于activity可见时执行 Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull, parameter favicon 原因webview监听favicon kotlin语法中需要判断为空可否 解决方法重写的onPageStarted方法类的favicon: Bitmap Bitmap后添加?使其可空即可 Recycleview data is not displayed 原因多重xml布局 recycleview id相同 解决方法修改ID为其他名称"},{"path":"/notes/Java/index.html","content":"相关日志警告OpenJDK 64-Bit Server VM warning: Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.Run &gt;&gt;&gt; Edit Configurations… ,找到 Spring boot 相关选项,取消勾选 Enable lanuch optimization即可 WARN 2776 — [kground-preinit] o.s.h.c.j.Jackson2ObjectMapperBuilder : For Jackson Kotlin classes support please add “com.fasterxml.jackson.module:jackson-module-kotlin” to the classpath通过https://mvnrepository.com获取jackson-module-kotlin依赖即可 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-kotlin&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt; spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning在application.yml配置文件中 is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.在连接字符串后面加上**?serverTimezone=UTC** Failed to load class “org.slf4j.impl.StaticLoggerBinder”. SLF4J: Defaulting to no-operation (NOP) logger implementation添加依赖解决"},{"path":"/wiki/tags/index.html","content":"TOC便笺undefinedAndroid 相关问题Android 相关问题Java 相关问题Java 相关问题"},{"path":"/wiki/tags/Java/index.html","content":"相关日志警告OpenJDK 64-Bit Server VM warning: Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.Run &gt;&gt;&gt; Edit Configurations… ,找到 Spring boot 相关选项,取消勾选 Enable lanuch optimization即可 WARN 2776 — [kground-preinit] o.s.h.c.j.Jackson2ObjectMapperBuilder : For Jackson Kotlin classes support please add “com.fasterxml.jackson.module:jackson-module-kotlin” to the classpath通过https://mvnrepository.com获取jackson-module-kotlin依赖即可 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-kotlin&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt; spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning在application.yml配置文件中 is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.在连接字符串后面加上**?serverTimezone=UTC** Failed to load class “org.slf4j.impl.StaticLoggerBinder”. SLF4J: Defaulting to no-operation (NOP) logger implementation添加依赖解决"},{"path":"/wiki/tags/Android/index.html","content":"相关编译错误Error running app：Default Activity not found在任务清单内为活动注册事件 1234567&lt;activity android:name=&quot;.SpalshActivity&quot; android:label=&quot;&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 提示Installation failed 检查包名是否存在大写字母,改为小写字母即可 检查setting下的build内install run第一选择是否被选中,若此则取消选中,然后保存即可 Unable to find optional library: org.apache.http.legacyHttpClient已经在API 23中删除在相应的module下的build.gradle中加入即可 123android &#123; useLibrary &#x27;org.apache.http.legacy&#x27;&#125; org.gradle.api.GradleException: Lint found fatal errors while assembling a release target 日志详情123456789org.gradle.api.GradleException: Lint found fatal errors while assembling a release target.To proceed, either fix the issues identified by lint, or modify your build script as follows:android &#123;lintOptions &#123;checkReleaseBuilds false// Or, if you prefer, you can continue to check for errors in release builds,// but continue the build even when errors are found:abortOnError false &#125;&#125; 原因分析Lint在编译release包的时候发现了致命的错误。 解决方法方法一：为了继续编译或解决Lint标记的问题，或许应该对你的构建脚本进行如下的改动，即在app主module的build.gradle里增加lintOptions，其中checkReleaseBuilds false表示在进行Release构建时不再进行Lint检查，abortOnError false则表示检查到错误后继续编译，不取消当前的构建任务。 1234lintOptions&#123; checkReleaseBuilds false abortOnError false &#125; 方法二：通过release编译打包时的编译打印日志内容中错误提示信息跳转对应布局文件中解决问题 Error message “Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8”Gradle JDK选择11 version 11.0.8/opt/android-studio-canaryl/jre即可 Caused by: java.lang.IllegalArgumentException: The given artifact contains a string literal with a package reference ‘android.support.v4.content’ that cannot be safely rewritten 原因support.v4库未找到Androidx支持类型 解决方法12345//引入ButterKnifeimplementation&quot;com.jakewharton:butterknife:10.0.0&quot;kapt &quot;com.jakewharton:butterknife-compiler:10.0.0&quot;//抽取功能组件apply plugin: &#x27;kotlin-kapt&#x27; 相关运行异常net::ERR_CLEARTEXT_NOT_PERMITTED 原因Android9.0以上无法直接加载http 多种解决方法一. application节点添加 二. targetSdkVersion 降级回至27三. 创建xml新建network_security_config在清单文件的application标签添加配置 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt; 四. 服务器和本地应用都改用 https The style on this component requires your app theme to be Theme.AppCompat (or a descendant).在引用这个自定义布局的界面根标签里，添加一行代码 Failure delivering result ResultInfo{. }to activity java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState 原因activity不可见时不执行数据文件传值操作 解决方法通过趣味问题的第一点解决 让这种逻辑处于activity可见时执行 Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull, parameter favicon 原因webview监听favicon kotlin语法中需要判断为空可否 解决方法重写的onPageStarted方法类的favicon: Bitmap Bitmap后添加?使其可空即可 Recycleview data is not displayed 原因多重xml布局 recycleview id相同 解决方法修改ID为其他名称"}]